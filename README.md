This is the day 15 end-of-day project of the 100 Days of Coding Udemy course. On day 15, we learn to apply more of the functions in a coffee machine code writing 4 of them. I am given a set of instructions in a pdf file, and as long as I follow the steps in order correctly, the program is supposed to work as intended. The first 34 lines of the code are given a dictionary, which is a dictionary of the profit, materials in the machine, and the materials needed to brew each type of drink which are espresso, latte, and cappuccino. We are given a certain amount of each, and the profit is set to 0 at the beginning of the program. As I mentioned before, there are four functions. The first function takes one argument, which is the order_ingredient. This function is explained as "returns if there are sufficient resources inside the machine for the order." So meaning that when the user inputs the order, this function compares the ingredients of the desired drink to the ingredients inside the machine. If the machine has enough resources to make the coffee, it just returns true and proceeds. If not, the machine returns false and gives a prompt saying there is not enough of a certain ingredient. The second function asks for the users to insert coins and keeps track of the money. For every quarter placed, it multiplies by the value of a quarter which is .25. For each coin, the function does the same thing and returns the total. Third function tests if the transaction is successful and takes two arguments which are the money received by the user, which we took the total payment in the previous function, and the cost of the drink, which was provided at the beginning of the program in the dictionary. If the money provided by the user is sufficient, it proceeds to make coffee. If not, the program returns false and refunds the user's money. If the provided money is enough, the profit variable of the program increases by the cost of the drink. If the money exceeds the required amount, the machine gives the change back to the user. The fourth function is finally making the coffee. This function takes two arguments the drink the user wants and the ordered ingredients. For the drink asked, the function deducts the ingredients from the ingredients given in the first dictionary. The for loop ensures that order ingredients are deducted one by one from the resources. As our functions are complete now, we are ready to get the program running. We start with a for loop and ask the user what he wants. The options, which are espresso, latte, and cappuccino, are provided in the input, so the user is supposed to put exactly one of those words. Be careful. It is case-sensitive, so there is a world of difference between "espresso" and "Espresso." A user knows only to put those words, but in case the admin comes, he knows a special word which is "report." What it does is that it asks to machine how many resources it has, and the program prints out all the resources one by one. An admin can type "report" and additional resources if needed. And the word "off" turns off the machine anytime it is written. Suppose a valid option is provided to the program; the program first of all checks if there are enough resources to make it by calling the first function. If it is true, it asks the user to insert coins. While processing coins, the program calls the second function and gets the total of the money provided. If money is sufficient, the program goes on to make the coffee, adds the cost of the coffee to the profit, and deducts the ingredients. After the functions are written well, it only takes 14 lines to run the program and call all the functions in the right place and order. It was a great exercise to work with the functions, and my project reached its goal. I did this project a while ago, and later on, I realized that it could have been done easily by using object-oriented programming. In other words, classes and objects. It would make the program way more efficient and robust. I wanted to upload this rather than the object-oriented version because this program has taught me that there is a better way to do it, and I will only get to know that if I learn more. By learning more, I realize how little I know each time. I have done the object-oriented version recently, and it is the best way of this program so far. Maybe in the future, I will look at it and laugh that there was a better way.
